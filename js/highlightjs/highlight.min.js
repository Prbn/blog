/*
  Highlight.js 10.5.0 (b4358b22)
  License: BSD-3-Clause
  Copyright (c) 2006-2020, Prabin Raj Shrestha
*/

var hljs = function () {
  "use strict";

  // Makes an object read-only by freezing it and preventing modifications to Map or Set.
  function e(t) {
    return t instanceof Map
      ? (t.clear = t.delete = t.set = () => {
          throw Error("map is read-only");
        })
      : t instanceof Set &&
        (t.add = t.clear = t.delete = () => {
          throw Error("set is read-only");
        }),
      Object.freeze(t),
      Object.getOwnPropertyNames(t).forEach((n) => {
        var s = t[n];
        // Recursively freeze nested objects if not already frozen.
        "object" != typeof s || Object.isFrozen(s) || e(s);
      }),
      t;
  }

  // Aliases for the freeze function.
  var t = e,
    n = e;
  t.default = n;

  // Represents a match context with data and an ignore flag.
  class s {
    constructor(e) {
      // Initialize data object if not provided.
      void 0 === e.data && (e.data = {}), (this.data = e.data);
    }
    // Marks the match to be ignored.
    ignoreMatch() {
      this.ignore = !0;
    }
  }

  // Escapes HTML characters to prevent injection in output.
  function r(e) {
    return e
      .replace(/&/g, "&")
      .replace(/</g, "<")
      .replace(/>/g, ">")
      .replace(/"/g, """)
      .replace(/'/g, "'");
  }

  // Merges multiple objects into a new object, overriding properties.
  function a(e, ...t) {
    const n = Object.create(null);
    for (const t in e) n[t] = e[t];
    return (
      t.forEach((e) => {
        for (const t in e) n[t] = e[t];
      }),
      n
    );
  }

  // Checks if a node has a 'kind' property.
  const i = (e) => !!e.kind;

  // Builds HTML output for highlighted code using a node walker.
  class o {
    constructor(e, t) {
      // Initialize buffer and class prefix for HTML spans.
      (this.buffer = ""), (this.classPrefix = t.classPrefix), e.walk(this);
    }
    // Appends escaped text to the buffer.
    addText(e) {
      this.buffer += r(e);
    }
    // Opens a span tag for a node with a specific kind.
    openNode(e) {
      if (!i(e)) return;
      let t = e.kind;
      // Prefix class unless it's a sublanguage.
      e.sublanguage || (t = `${this.classPrefix}${t}`), this.span(t);
    }
    // Closes a span tag if the node has a kind.
    closeNode(e) {
      i(e) && (this.buffer += "</span>");
    }
    // Returns the final HTML string.
    value() {
      return this.buffer;
    }
    // Appends an opening span tag with the given class.
    span(e) {
      this.buffer += `<span class="${e}">`;
    }
  }

  // Represents a tree structure for syntax nodes.
  class l {
    constructor() {
      // Initialize root node and stack for tree traversal.
      (this.rootNode = { children: [] }), (this.stack = [this.rootNode]);
    }
    // Gets the top node in the stack.
    get top() {
      return this.stack[this.stack.length - 1];
    }
    // Gets the root node.
    get root() {
      return this.rootNode;
    }
    // Adds a node to the current top node's children.
    add(e) {
      this.top.children.push(e);
    }
    // Creates and pushes a new node with the given kind.
    openNode(e) {
      const t = { kind: e, children: [] };
      this.add(t), this.stack.push(t);
    }
    // Pops a node from the stack if more than one exists.
    closeNode() {
      if (this.stack.length > 1) return this.stack.pop();
    }
    // Closes all nodes until only the root remains.
    closeAllNodes() {
      for (; this.closeNode(); );
    }
    // Serializes the tree to JSON with indentation.
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    // Walks the tree using a provided walker.
    walk(e) {
      return this.constructor._walk(e, this.rootNode);
    }
    // Static method to walk the tree, handling text and child nodes.
    static _walk(e, t) {
      return "string" == typeof t
        ? e.addText(t)
        : t.children &&
            (e.openNode(t),
              t.children.forEach((t) => this._walk(e, t)),
              e.closeNode(t)),
        e;
    }
    // Collapses consecutive string children into a single string.
    static _collapse(e) {
      "string" != typeof e &&
        e.children &&
        (e.children.every((e) => "string" == typeof e)
          ? (e.children = [e.children.join("")])
          : e.children.forEach((e) => {
              l._collapse(e);
            }));
    }
  }

  // Extends the tree class to emit highlighted HTML output.
  class c extends l {
    constructor(e) {
      super(), (this.options = e);
    }
    // Adds a keyword with a specific kind to the tree.
    addKeyword(e, t) {
      "" !== e && (this.openNode(t), this.addText(e), this.closeNode());
    }
    // Adds text to the current node.
    addText(e) {
      "" !== e && this.add(e);
    }
    // Adds a sublanguage's root node with a specific kind.
    addSublanguage(e, t) {
      const n = e.root;
      (n.kind = t), (n.sublanguage = !0), this.add(n);
    }
    // Converts the tree to HTML using the HTML emitter.
    toHTML() {
      return new o(this, this.options).value();
    }
    // Signals completion of processing.
    finalize() {
      return !0;
    }
  }

  // Converts a regex or string to a source string, handling null.
  function u(e) {
    return e ? ("string" == typeof e ? e : e.source) : null;
  }

  // Regular expression patterns for language constructs.
  const g = "[a-zA-Z]\\w*", // Identifier starting with a letter.
    d = "[a-zA-Z_]\\w*", // Identifier starting with letter or underscore.
    h = "\\b\\d+(\\.\\d+)?", // Decimal number.
    f =
      "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", // Hex or scientific notation.
    p = "\\b(0b[01]+)", // Binary number.
    m = { begin: "\\\\[\\s\\S]", relevance: 0 }, // Backslash escape.
    b = {
      className: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [m],
    }, // Single-quoted string.
    x = {
      className: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [m],
    }, // Double-quoted string.
    E = {
      begin:
        /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
    }, // Common English words for relevance.
    // Creates a comment mode with start, end, and optional extra rules.
    v = (e, t, n = {}) => {
      const s = a({ className: "comment", begin: e, end: t, contains: [] }, n);
      return (
        s.contains.push(E),
        s.contains.push({
          className: "doctag",
          begin: "(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",
          relevance: 0,
        }),
        s
      );
    },
    w = v("//", "$"), // Single-line comment (C-style).
    N = v("/\\*", "\\*/"), // Multi-line comment (C-style).
    y = v("#", "$"); // Single-line comment (script-style).

  // Language mode definitions and utilities.
  var R = Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE: /\b\B/, // Matches nothing.
    IDENT_RE: g,
    UNDERSCORE_IDENT_RE: d,
    NUMBER_RE: h,
    C_NUMBER_RE: f,
    BINARY_NUMBER_RE: p,
    RE_STARTERS_RE:
      "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", // Operator tokens.
    SHEBANG: (e = {}) => {
      const t = /^#![ ]*\//; // Shebang start.
      return (
        e.binary &&
          (e.begin = ((...e) => e.map((e) => u(e)).join(""))(
            t,
            /.*\b/,
            e.binary,
            /\b.*/,
          )),
        a(
          {
            className: "meta",
            begin: t,
            end: /$/,
            relevance: 0,
            "on:begin": (e, t) => {
              0 !== e.index && t.ignoreMatch(); // Ignore if not at line start.
            },
          },
          e
        )
      );
    },
    BACKSLASH_ESCAPE: m,
    APOS_STRING_MODE: b,
    QUOTE_STRING_MODE: x,
    PHRASAL_WORDS_MODE: E,
    COMMENT: v,
    C_LINE_COMMENT_MODE: w,
    C_BLOCK_COMMENT_MODE: N,
    HASH_COMMENT_MODE: y,
    NUMBER_MODE: { className: "number", begin: h, relevance: 0 },
    C_NUMBER_MODE: { className: "number", begin: f, relevance: 0 },
    BINARY_NUMBER_MODE: { className: "number", begin: p, relevance: 0 },
    CSS_NUMBER_MODE: {
      className: "number",
      begin:
        h +
        "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?", // CSS units.
      relevance: 0,
    },
    REGEXP_MODE: {
      begin: /(?=\/[^/\n]*\/)/, // Lookahead for regex.
      contains: [
        {
          className: "regexp",
          begin: /\//,
          end: /\/[gimuy]*/,
          illegal: /\n/,
          contains: [m, { begin: /\[/, end: /\]/, relevance: 0, contains: [m] }],
        },
      ],
    },
    TITLE_MODE: { className: "title", begin: g, relevance: 0 },
    UNDERSCORE_TITLE_MODE: { className: "title", begin: d, relevance: 0 },
    METHOD_GUARD: { begin: "\\.\\s*[a-zA-Z_]\\w*", relevance: 0 }, // Prevents method-like matches.
    END_SAME_AS_BEGIN: (e) =>
      Object.assign(e, {
        "on:begin": (e, t) => {
          t.data._beginMatch = e[1]; // Store begin match.
        },
        "on:end": (e, t) => {
          t.data._beginMatch !== e[1] && t.ignoreMatch(); // Ignore if end doesn't match begin.
        },
      }),
  });

  // Ignores matches preceded by a dot to avoid method calls.
  function _(e, t) {
    "." === e.input[e.index - 1] && t.ignoreMatch();
  }

  // Processes beginKeywords to create a regex pattern.
  function k(e, t) {
    t &&
      e.beginKeywords &&
      ((e.begin =
        "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)"),
      (e.__beforeBegin = _),
      (e.keywords = e.keywords || e.beginKeywords),
      delete e.beginKeywords,
      void 0 === e.relevance && (e.relevance = 0));
  }

  // Converts illegal array to a regex pattern.
  function O(e, t) {
    Array.isArray(e.illegal) &&
      (e.illegal = ((...e) => "(" + e.map((e) => u(e)).join("|") + ")")(
        ...e.illegal
      ));
  }

  // Converts match to begin for compatibility.
  function M(e, t) {
    if (e.match) {
      if (e.begin || e.end)
        throw Error("begin & end are not supported with match");
      (e.begin = e.match), delete e.match;
    }
  }

  // Sets default relevance if not specified.
  function A(e, t) {
    void 0 === e.relevance && (e.relevance = 1);
  }

  // Common keywords with low relevance.
  const L = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    "list",
    "value",
  ];

  // Processes keywords for highlighting, handling case sensitivity.
  function B(e, t, n = "keyword") {
    const s = {};
    return (
      "string" == typeof e
        ? r(n, e.split(" "))
        : Array.isArray(e)
        ? r(n, e)
        : Object.keys(e).forEach((n) => {
            Object.assign(s, B(e[n], t, n));
          }),
      s
    );

    function r(e, n) {
      t && (n = n.map((e) => e.toLowerCase())),
        n.forEach((t) => {
          const n = t.split("|");
          s[n[0]] = [e, I(n[0], n[1])];
        });
    }
  }

  // Determines keyword relevance, with special handling for common words.
  function I(e, t) {
    return t
      ? Number(t)
      : ((e) => L.includes(e.toLowerCase()))(e)
      ? 0
      : 1;
  }

  // Compiles language rules into a matcher for tokenization.
  function T(e, { plugins: t }) {
    // Creates a regex with specified flags.
    function n(t, n) {
      return RegExp(
        u(t),
        "m" + (e.case_insensitive ? "i" : "") + (n ? "g" : "")
      );
    }

    // Manages regex rules for matching.
    class s {
      constructor() {
        (this.matchIndexes = {}),
          (this.regexes = []),
          (this.matchAt = 1),
          (this.position = 0);
      }
      // Adds a regex rule with associated metadata.
      addRule(e, t) {
        (t.position = this.position++),
          (this.matchIndexes[this.matchAt] = t),
          this.regexes.push([t, e]),
          (this.matchAt +=
            ((e) => RegExp(e.toString() + "|").exec("").length - 1)(e) + 1);
      }
      // Compiles all regexes into a single matcher.
      compile() {
        0 === this.regexes.length && (this.exec = () => null);
        const e = this.regexes.map((e) => e[1]);
        (this.matcherRe = n(
          ((e, t = "|") => {
            const n = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
            let s = 0,
              r = "";
            for (let a = 0; a < e.length; a++) {
              s += 1;
              const i = s;
              let o = u(e[a]);
              for (a > 0 && (r += t), r += "("; o.length > 0; ) {
                const e = n.exec(o);
                if (null == e) {
                  r += o;
                  break;
                }
                (r += o.substring(0, e.index)),
                  (o = o.substring(e.index + e[0].length)),
                  "\\" === e[0][0] && e[1]
                    ? (r += "\\" + (Number(e[1]) + i))
                    : ((r += e[0]), "(" === e[0] && s++);
              }
              r += ")";
            }
            return r;
          })(e),
          !0
        )),
          (this.lastIndex = 0);
      }
      // Executes the matcher on input text.
      exec(e) {
        this.matcherRe.lastIndex = this.lastIndex;
        const t = this.matcherRe.exec(e);
        if (!t) return null;
        const n = t.findIndex((e, t) => t > 0 && void 0 !== e),
          s = this.matchIndexes[n];
        return t.splice(0, n), Object.assign(t, s);
      }
    }

    // Manages multiple regex matchers for a language.
    class r {
      constructor() {
        (this.rules = []),
          (this.multiRegexes = []),
          (this.count = 0),
          (this.lastIndex = 0),
          (this.regexIndex = 0);
      }
      // Retrieves or creates a matcher for a given index.
      getMatcher(e) {
        if (this.multiRegexes[e]) return this.multiRegexes[e];
        const t = new s();
        return (
          this.rules.slice(e).forEach(([e, n]) => t.addRule(e, n)),
          t.compile(),
          (this.multiRegexes[e] = t),
          t
        );
      }
      // Checks if scanning should resume at the same position.
      resumingScanAtSamePosition() {
        return 0 !== this.regexIndex;
      }
      // Resets the regex index to consider all rules.
      considerAll() {
        this.regexIndex = 0;
      }
      // Adds a rule to the matcher.
      addRule(e, t) {
        this.rules.push([e, t]), "begin" === t.type && this.count++;
      }
      // Executes the appropriate matcher on input text.
      exec(e) {
        const t = this.getMatcher(this.regexIndex);
        t.lastIndex = this.lastIndex;
        let n = t.exec(e);
        if (this.resumingScanAtSamePosition())
          if (n && n.index === this.lastIndex);
          else {
            const t = this.getMatcher(0);
            (t.lastIndex = this.lastIndex + 1), (n = t.exec(e));
          }
        return (
          n &&
            ((this.regexIndex += n.position + 1),
            this.regexIndex === this.count && this.considerAll()),
          n
        );
      }
    }

    // Validates language definition to prevent self-referential errors.
    if (
      (e.compilerExtensions || (e.compilerExtensions = []),
      e.contains && e.contains.includes("self"))
    )
      throw Error(
        "ERR: contains `self` is not supported at the top-level of a language.  See documentation."
      );

    return (
      (e.classNameAliases = a(e.classNameAliases || {})),
      // Compiles a language mode recursively.
      (function t(s, i) {
        const o = s;
        if (s.compiled) return o;
        // Apply preprocessing transformations.
        [M].forEach((e) => e(s, i)),
          e.compilerExtensions.forEach((e) => e(s, i)),
          (s.__beforeBegin = null),
          [k, O, A].forEach((e) => e(s, i)),
          (s.compiled = !0);
        let l = null;
        // Handle keyword patterns.
        if (
          ("object" == typeof s.keywords &&
            ((l = s.keywords.$pattern), delete s.keywords.$pattern),
          s.keywords && (s.keywords = B(s.keywords, e.case_insensitive)),
          s.lexemes && l)
        )
          throw Error(
            "ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) "
          );
        return (
          (l = l || s.lexemes || /\w+/),
          (o.keywordPatternRe = n(l, !0)),
          // Configure begin/end regexes and terminators.
          i &&
            (s.begin || (s.begin = /\B|\b/),
            (o.beginRe = n(s.begin)),
            s.endSameAsBegin && (s.end = s.begin),
            s.end || s.endsWithParent || (s.end = /\B|\b/),
            s.end && (o.endRe = n(s.end)),
            (o.terminatorEnd = u(s.end) || ""),
            s.endsWithParent &&
              i.terminatorEnd &&
              (o.terminatorEnd += (s.end ? "|" : "") + i.terminatorEnd)),
          s.illegal && (o.illegalRe = n(s.illegal)),
          s.contains || (s.contains = []),
          // Process contained modes, handling variants and self-references.
          (s.contains = [].concat(
            ...s.contains.map((e) =>
              ((e) => (
                e.variants &&
                  !e.cachedVariants &&
                  (e.cachedVariants = e.variants.map((t) =>
                    a(e, { variants: null }, t)
                  )),
                e.cachedVariants
                  ? e.cachedVariants
                  : j(e)
                  ? a(e, { starts: e.starts ? a(e.starts) : null })
                  : Object.isFrozen(e)
                  ? a(e)
                  : e
              ))("self" === e ? s : e)
            )
          )),
          s.contains.forEach((e) => {
            t(e, o);
          }),
          s.starts && t(s.starts, i),
          // Create the matcher for this mode.
          (o.matcher = ((e) => {
            const t = new r();
            return (
              e.contains.forEach((e) =>
                t.addRule(e.begin, { rule: e, type: "begin" })
              ),
              e.terminatorEnd && t.addRule(e.terminatorEnd, { type: "end" }),
              e.illegal && t.addRule(e.illegal, { type: "illegal" }),
              t
            );
          })(o)),
          o
        );
      })(e)
    );
  }

  // Checks if a mode ends with its parent or has a starting parent.
  function j(e) {
    return !!e && (e.endsWithParent || j(e.starts));
  }

  // Vue component for rendering highlighted code.
  function S(e) {
    const t = {
      props: ["language", "code", "autodetect"],
      data: () => ({ detectedLanguage: "", unknownLanguage: !1 }),
      computed: {
        // Determines the CSS class for the code block.
        className() {
          return this.unknownLanguage ? "" : "hljs " + this.detectedLanguage;
        },
        // Highlights the code, handling autodetection or specific languages.
        highlighted() {
          if (!this.autoDetect && !e.getLanguage(this.language))
            return (
              console.warn(
                `The language "${this.language}" you specified could not be found.`
              ),
              (this.unknownLanguage = !0),
              r(this.code)
            );
          let t = {};
          return (
            this.autoDetect
              ? ((t = e.highlightAuto(this.code)),
                (this.detectedLanguage = t.language))
              : ((t = e.highlight(this.language, this.code, this.ignoreIllegals)),
                (this.detectedLanguage = this.language)),
            t.value
          );
        },
        // Determines if autodetection is enabled.
        autoDetect() {
          return !(
            this.language &&
            ((e = this.autodetect), !e && "" !== e)
          );
          var e;
        },
        // Always ignores illegal matches.
        ignoreIllegals: () => !0,
      },
      // Renders the highlighted code in a pre/code structure.
      render(e) {
        return e("pre", {}, [
          e("code", {
            class: this.className,
            domProps: { innerHTML: this.highlighted },
          }),
        ]);
      },
    };
    return {
      Component: t,
      VuePlugin: { install(e) { e.component("highlightjs", t); } },
    };
  }

  // Plugin to synchronize HTML structure with highlighted output.
  const P = {
    "after:highlightBlock": ({ block: e, result: t, text: n }) => {
      const s = C(e);
      if (!s.length) return;
      const a = document.createElement("div");
      a.innerHTML = t.value;
      // Rebuilds HTML to match the original DOM structure.
      t.value = ((e, t, n) => {
        let s = 0,
          a = "";
        const i = [];
        function o() {
          return e.length && t.length
            ? e[0].offset !== t[0].offset
              ? e[0].offset < t[0].offset
                ? e
                : t
              : "start" === t[0].event
              ? e
              : t
            : e.length
            ? e
            : t;
        }
        function l(e) {
          a +=
            "<" +
            D(e) +
            [].map
              .call(e.attributes, function (e) {
                return " " + e.nodeName + '="' + r(e.value) + '"';
              })
              .join("") +
            ">";
        }
        function c(e) {
          a += "</" + D(e) + ">";
        }
        function u(e) {
          ("start" === e.event ? l : c)(e.node);
        }
        for (; e.length || t.length; ) {
          let t = o();
          if (
            ((a += r(n.substring(s, t[0].offset))), (s = t[0].offset), t === e)
          ) {
            i.reverse().forEach(c);
            do {
              u(t.splice(0, 1)[0]), (t = o());
            } while (t === e && t.length && t[0].offset === s);
            i.reverse().forEach(l);
          } else
            "start" === t[0].event ? i.push(t[0].node) : i.pop(),
              u(t.splice(0, 1)[0]);
        }
        return a + r(n.substr(s));
      })(s, C(a), n);
    },
  };

  // Converts a node name to lowercase.
  function D(e) {
    return e.nodeName.toLowerCase();
  }

  // Builds a list of DOM node events with offsets.
  function C(e) {
    const t = [];
    return (function e(n, s) {
      for (let r = n.firstChild; r; r = r.nextSibling)
        3 === r.nodeType
          ? (s += r.nodeValue.length)
          : 1 === r.nodeType &&
            (t.push({ event: "start", offset: s, node: r }),
            (s = e(r, s)),
            D(r).match(/br|hr|img|input/) ||
              t.push({ event: "stop", offset: s, node: r }));
      return s;
    })(e, 0), t;
  }

  // Error logging function.
  const H = (e) => {
      console.error(e);
    },
    // Warning logging function.
    U = (e, ...t) => {
      console.log("WARN: " + e, ...t);
    },
    // Deprecation warning function.
    $ = (e, t) => {
      console.log(`Deprecated as of ${e}. ${t}`);
    },
    z = r,
    K = a,
    G = Symbol("nomatch");

  // Main Highlight.js initialization and API.
  return ((e) => {
    const n = Object.create(null), // Language definitions.
      r = Object.create(null), // Language aliases.
      a = []; // Plugins.
    let i = !0; // Debug mode flag.
    const o = /(^(<[^>]+>|\t|)+|\n)/gm, // Whitespace and tag pattern.
      l =
        "Could not find the language '{}', did you forget to load/include a language module?",
      u = { disableAutodetect: !0, name: "Plain text", contains: [] }; // Plain text mode.
    let g = {
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      tabReplace: null,
      useBR: !1,
      languages: null,
      __emitter: c,
    };

    // Checks if a class name indicates no highlighting.
    function d(e) {
      return g.noHighlightRe.test(e);
    }

    // Highlights code with a specified language or autodetection.
    function h(e, t, n, s) {
      const r = { code: t, language: e };
      M("before:highlight", r);
      const a = r.result ? r.result : f(r.language, r.code, n, s);
      return (a.code = r.code), M("after:highlight", a), a;
    }

    // Core highlighting function for a single language.
    function f(e, t, r, o) {
      const c = t;
      // Checks if a keyword exists in the mode's keyword list.
      function u(e, t) {
        const n = w.case_insensitive ? t[0].toLowerCase() : t[0];
        return (
          Object.prototype.hasOwnProperty.call(e.keywords, n) && e.keywords[n]
        );
      }
      // Processes the current mode (sublanguage or keywords).
      function d() {
        null != R.subLanguage
          ? (() => {
              if ("" === M) return;
              let e = null;
              if ("string" == typeof R.subLanguage) {
                if (!n[R.subLanguage]) return void O.addText(M);
                e = f(R.subLanguage, M, !0, k[R.subLanguage]);
                k[R.subLanguage] = e.top;
              } else e = p(M, R.subLanguage.length ? R.subLanguage : null);
              R.relevance > 0 && (A += e.relevance),
                O.addSublanguage(e.emitter, e.language);
            })()
          : (() => {
              if (!R.keywords) return void O.addText(M);
              let e = 0;
              R.keywordPatternRe.lastIndex = 0;
              let t = R.keywordPatternRe.exec(M),
                n = "";
              for (; t; ) {
                n += M.substring(e, t.index);
                const s = u(R, t);
                if (s) {
                  const [e, r] = s;
                  O.addText(n), (n = ""), (A += r);
                  const a = w.classNameAliases[e] || e;
                  O.addKeyword(t[0], a);
                } else n += t[0];
                e = R.keywordPatternRe.lastIndex;
                t = R.keywordPatternRe.exec(M);
              }
              n += M.substr(e), O.addText(n);
            })(),
          (M = "");
      }
      // Opens a new mode with the given class name.
      function h(e) {
        return (
          e.className && O.openNode(w.classNameAliases[e.className] || e.className),
          (R = Object.create(e, { parent: { value: R } })),
          R
        );
      }
      // Checks if the mode ends and returns to the parent.
      function m(e, t, n) {
        let r = ((e, t) => {
          const n = e && e.exec(t);
          return n && 0 === n.index;
        })(e.endRe, n);
        if (r) {
          if (e["on:end"]) {
            const n = new s(e);
            e["on:end"](t, n), n.ignore && (r = !1);
          }
          if (r) {
            for (; e.endsParent && e.parent; ) e = e.parent;
            return e;
          }
        }
        if (e.endsWithParent) return m(e.parent, t, n);
      }
      // Handles skipped matches.
      function b(e) {
        return 0 === R.matcher.regexIndex ? ((M += e[0]), 1) : ((I = !0), 0);
      }
      // Processes the end of a mode.
      function x(e) {
        const t = e[0],
          n = c.substr(e.index),
          s = m(R, e, n);
        if (!s) return G;
        const r = R;
        r.skip
          ? (M += t)
          : (r.returnEnd || r.excludeEnd || (M += t),
            d(),
            r.excludeEnd && (M = t));
        do {
          R.className && O.closeNode(),
            R.skip || R.subLanguage || (A += R.relevance),
            (R = R.parent);
        } while (R !== s.parent);
        return (
          s.starts &&
            (s.endSameAsBegin && (s.starts.endRe = s.endRe), h(s.starts)),
          r.returnEnd ? 0 : t.length
        );
      }
      let E = {};
      // Main tokenization loop.
      function v(t, n) {
        const a = n && n[0];
        if ((M += t), null == a) return d(), 0;
        if (
          "begin" === E.type &&
          "end" === n.type &&
          E.index === n.index &&
          "" === a
        ) {
          if (((M += c.slice(n.index, n.index + 1)), !i)) {
            const t = Error("0 width match regex");
            throw ((t.languageName = e), (t.badRule = E.rule), t);
          }
          return 1;
        }
        if (((E = n), "begin" === n.type))
          return (function (e) {
            const t = e[0],
              n = e.rule,
              r = new s(n),
              a = [n.__beforeBegin, n["on:begin"]];
            for (const n of a)
              if (n && (n(e, r), r.ignore)) return b(t);
            return (
              n &&
                n.endSameAsBegin &&
                (n.endRe = RegExp(
                  t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"),
                  "m"
                )),
              n.skip
                ? (M += t)
                : (n.excludeBegin && (M += t),
                  d(),
                  n.returnBegin || n.excludeBegin || (M = t)),
              h(n),
              n.returnBegin ? 0 : t.length
            );
          })(n);
        if ("illegal" === n.type && !r) {
          const e = Error(
            'Illegal lexeme "' +
              a +
              '" for mode "' +
              (R.className || "<unnamed>") +
              '"'
          );
          throw ((e.mode = R), e);
        }
        if ("end" === n.type) {
          const e = x(n);
          if (e !== G) return e;
        }
        if ("illegal" === n.type && "" === a) return 1;
        if (B > 1e5 && B > 3 * n.index)
          throw Error("potential infinite loop, way more iterations than matches");
        return (M += a), a.length;
      }
      const w = _(e);
      if (!w) throw (H(l.replace("{}", e)), Error('Unknown language: "' + e + '"'));
      const N = T(w, { plugins: a });
      let y = "",
        R = o || N;
      const k = {},
        O = new g.__emitter(g);
      // Initialize emitter with parent class names.
      (() => {
        const e = [];
        for (let t = R; t !== w; t = t.parent) t.className && e.unshift(t.className);
        e.forEach((e) => O.openNode(e));
      })();
      let M = "",
        A = 0,
        L = 0,
        B = 0,
        I = !1;
      try {
        for (R.matcher.considerAll(); ; ) {
          B++, I ? (I = !1) : R.matcher.considerAll(), (R.matcher.lastIndex = L);
          const e = R.matcher.exec(c);
          if (!e) break;
          const t = v(c.substring(L, e.index), e);
          L = e.index + t;
        }
        return (
          v(c.substr(L)),
          O.closeAllNodes(),
          O.finalize(),
          (y = O.toHTML()),
          {
            relevance: Math.floor(A),
            value: y,
            language: e,
            illegal: !1,
            emitter: O,
            top: R,
          }
        );
      } catch (t) {
        if (t.message && t.message.includes("Illegal"))
          return {
            illegal: !0,
            illegalBy: {
              msg: t.message,
              context: c.slice(L - 100, L + 100),
              mode: t.mode,
            },
            sofar: y,
            relevance: 0,
            value: z(c),
            emitter: O,
          };
        if (i)
          return {
            illegal: !1,
            relevance: 0,
            value: z(c),
            emitter: O,
            language: e,
            top: R,
            errorRaised: t,
          };
        throw t;
      }
    }

    // Autodetects the best language for highlighting.
    function p(e, t) {
      t = t || g.languages || Object.keys(n);
      const s = ((e) => {
        const t = {
          relevance: 0,
          emitter: new g.__emitter(g),
          value: z(e),
          illegal: !1,
          top: u,
        };
        return t.emitter.addText(e), t;
      })(e),
        r = t
          .filter(_)
          .filter(O)
          .map((t) => f(t, e, !1));
      r.unshift(s);
      const a = r.sort((e, t) => {
        if (e.relevance !== t.relevance) return t.relevance - e.relevance;
        if (e.language && t.language) {
          if (_(e.language).supersetOf === t.language) return 1;
          if (_(t.language).supersetOf === e.language) return -1;
        }
        return 0;
      }),
        [i, o] = a,
        l = i;
      return (
        (l.second_best = o),
        l
      );
    }

    // Plugin to handle line breaks and BR tags.
    const m = {
      "before:highlightBlock": ({ block: e }) => {
        g.useBR &&
          (e.innerHTML = e.innerHTML.replace(/\n/g, "").replace(/<br[ /]*>/g, "\n"));
      },
      "after:highlightBlock": ({ result: e }) => {
        g.useBR && (e.value = e.value.replace(/\n/g, "<br>"));
      },
    },
      b = /^(<[^>]+>|\t)+/gm,
      // Plugin to replace tabs with spaces.
      x = {
        "after:highlightBlock": ({ result: e }) => {
          g.tabReplace &&
            (e.value = e.value.replace(b, (e) =>
              e.replace(/\t/g, g.tabReplace)
            ));
        },
      };

    // Highlights a DOM block with the appropriate language.
    function E(e) {
      let t = null;
      const n = ((e) => {
        let t = e.className + " ";
        t += e.parentNode ? e.parentNode.className : "";
        const n = g.languageDetectRe.exec(t);
        if (n) {
          const t = _(n[1]);
          return (
            t ||
              (U(l.replace("{}", n[1])),
              U("Falling back to no-highlight mode for this block.", e)),
            t ? n[1] : "no-highlight"
          );
        }
        return t.split(/\s+/).find((e) => d(e) || _(e));
      })(e);
      if (d(n)) return;
      M("before:highlightBlock", { block: e, language: n }),
        (t = e);
      const s = t.textContent,
        a = n ? h(n, s, !0) : p(s);
      M("after:highlightBlock", { block: e, result: a, text: s }),
        (e.innerHTML = a.value),
        ((e, t, n) => {
          const s = t ? r[t] : n;
          e.classList.add("hljs"), s && e.classList.add(s);
        })(e, n, a.language),
        (e.result = {
          language: a.language,
          re: a.relevance,
          relavance: a.relevance,
        }),
        a.second_best &&
          (e.second_best = {
            language: a.second_best.language,
            re: a.second_best.relevance,
            relavance: a.second_best.relevance,
          });
    }

    // Deprecated initialization function.
    const v = () => {
      v.called ||
        ((v.called = !0),
        $(
          "10.6.0",
          "initHighlighting() is deprecated.  Use highlightAll() instead."
        ),
        document.querySelectorAll("pre code").forEach(E));
    };

    let w = !1,
      N = !1;

    // Highlights all pre/code blocks on the page.
    function y() {
      N ? document.querySelectorAll("pre code").forEach(E) : (w = !0);
    }

    // Retrieves a language definition by name or alias.
    function _(e) {
      return (e = (e || "").toLowerCase()), n[e] || n[r[e]];
    }

    // Registers language aliases.
    function k(e, { languageName: t }) {
      "string" == typeof e && (e = [e]),
        e.forEach((e) => {
          r[e] = t;
        });
    }

    // Checks if a language supports autodetection.
    function O(e) {
      const t = _(e);
      return t && !t.disableAutodetect;
    }

    // Triggers plugin callbacks for an event.
    function M(e, t) {
      const n = e;
      a.forEach((e) => {
        e[n] && e[n](t);
      });
    }

    // Initialize highlighting on DOM content loaded.
    "undefined" != typeof window &&
      window.addEventListener &&
      window.addEventListener(
        "DOMContentLoaded",
        () => {
          (N = !0), w && y();
        },
        !1
      ),
      // Public API methods.
      Object.assign(e, {
        highlight: h,
        highlightAuto: p,
        highlightAll: y,
        fixMarkup: (e) => {
          return (
            $(
              "10.2.0",
              "fixMarkup will be removed entirely in v11.0"
            ),
            $(
              "10.2.0",
              "Please see https://github.com/highlightjs/highlight.js/issues/2534"
            ),
            (t = e),
            g.tabReplace || g.useBR
              ? t.replace(o, (e) =>
                  "\n" === e
                    ? g.useBR
                      ? "<br>"
                      : e
                    : g.tabReplace
                    ? e.replace(/\t/g, g.tabReplace)
                    : e
                )
              : t
          );
          var t;
        },
        highlightBlock: E,
        configure: (e) => {
          e.useBR &&
            ($(
              "10.3.0",
              "'useBR' will be removed entirely in v11.0"
            ),
            $(
              "10.3.0",
              "Please see https://github.com/highlightjs/highlight.js/issues/2559"
            )),
            (g = K(g, e));
        },
        initHighlighting: v,
        initHighlightingOnLoad: () => {
          $(
            "10.6.0",
            "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead."
          ),
            (w = !0);
        },
        registerLanguage: (t, s) => {
          let r = null;
          try {
            r = s(e);
          } catch (e) {
            if (
              (H(
                "Language definition for '{}' could not be registered.".replace(
                  "{}",
                  t
                )
              ),
              !i)
            )
              throw e;
            H(e), (r = u);
          }
          r.name || (r.name = t),
            (n[t] = r),
            (r.rawDefinition = s.bind(null, e)),
            r.aliases && k(r.aliases, { languageName: t });
        },
        listLanguages: () => Object.keys(n),
        getLanguage: _,
        registerAliases: k,
        requireLanguage: (e) => {
          $(
            "10.4.0",
            "requireLanguage will be removed entirely in v11."
          ),
            $(
              "10.4.0",
              "Please see https://github.com/highlightjs/highlight.js/pull/2844"
            );
          const t = _(e);
          if (t) return t;
          throw Error(
            "The '{}' language is required, but not loaded.".replace("{}", e)
          );
        },
        autoDetection: O,
        inherit: K,
        addPlugin: (e) => {
          a.push(e);
        },
        vuePlugin: S(e).VuePlugin,
      }),
      (e.debugMode = () => {
        i = !1;
      }),
      (e.safeMode = () => {
        i = !0;
      }),
      (e.versionString = "10.5.0");
    for (const e in R) "object" == typeof R[e] && t(R[e]);
    return (
      Object.assign(e, R),
      e.addPlugin(m),
      e.addPlugin(P),
      e.addPlugin(x),
      e
    );
  })({});
})();
"object" == typeof exports &&
  "undefined" != typeof module &&
  (module.exports = hljs);
